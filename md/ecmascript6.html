<!DOCTYPE  html>
<html>
  <head>
    <meta charset="utf-8">
    
    <title>doc</title>
    <style>
      /*github.com style (c) Vasily Polovnyov <vast@whiteants.net>*/
      pre code {
        display: block; padding: 0.5em;
        color: #333;
        background: #f8f8ff
      }
      pre .comment,
      pre .template_comment,
      pre .diff .header,
      pre .javadoc {
        color: #998;
        font-style: italic
      }
      pre .keyword,
      pre .css .rule .keyword,
      pre .winutils,
      pre .javascript .title,
      pre .nginx .title,
      pre .subst,
      pre .request,
      pre .status {
        color: #333;
        font-weight: bold
      }
      pre .number,
      pre .hexcolor,
      pre .ruby .constant {
        color: #099;
      }
      pre .string,
      pre .tag .value,
      pre .phpdoc,
      pre .tex .formula {
        color: #d14
      }
      pre .title,
      pre .id {
        color: #900;
        font-weight: bold
      }
      pre .javascript .title,
      pre .lisp .title,
      pre .clojure .title,
      pre .subst {
        font-weight: normal
      }
      pre .class .title,
      pre .haskell .type,
      pre .vhdl .literal,
      pre .tex .command {
        color: #458;
        font-weight: bold
      }
      pre .tag,
      pre .tag .title,
      pre .rules .property,
      pre .django .tag .keyword {
        color: #000080;
        font-weight: normal
      }
      pre .attribute,
      pre .variable,
      pre .lisp .body {
        color: #008080
      }
      pre .regexp {
        color: #009926
      }
      pre .class {
        color: #458;
        font-weight: bold
      }
      pre .symbol,
      pre .ruby .symbol .string,
      pre .lisp .keyword,
      pre .tex .special,
      pre .prompt {
        color: #990073
      }
      pre .built_in,
      pre .lisp .title,
      pre .clojure .built_in {
        color: #0086b3
      }
      pre .preprocessor,
      pre .pi,
      pre .doctype,
      pre .shebang,
      pre .cdata {
        color: #999;
        font-weight: bold
      }
      pre .deletion {
        background: #fdd
      }
      pre .addition {
        background: #dfd
      }
      pre .diff .change {
        background: #0086b3
      }
      pre .chunk {
        color: #aaa
      }
    </style>
  </head>
  <body>  
    <h1 id="ecmascript-6-es2015-es6">ECMAScript 6 | ES2015 | ES6</h1>
<h2 id="index">Index</h2>
<ul>
<li><a href="#variables">Variables</a><ul>
<li><a href="#let">let</a></li>
<li><a href="#const">const</a></li>
<li><a href="#replace-iifes-with-blocks">Replace IIFEs with blocks</a></li>
</ul>
</li>
<li><a href="#string-templates">String templates</a></li>
<li><a href="#destructuring">Destructuring</a><ul>
<li><a href="#spread-operator">Spread operator</a></li>
</ul>
</li>
<li><a href="#function-parameters">Function parameters</a></li>
<li><a href="#arrow-functions">Arrow functions</a></li>
<li><a href="#classes">Classes</a></li>
<li><a href="#getters-and-setters">Getters and setters</a></li>
</ul>
<h1 id="content">Content</h1>
<h2 id="variables">Variables</h2>
<h3 id="-let-"><code>let</code></h3>
<p>It is like <code>var</code> but with blocking (what is inside curly braces) scope.</p>
<pre><code class="lang-js">if (true) {
    let test = &#39;hello&#39;;
}
console.log(test); // undefined</code></pre>
<h3 id="-const-"><code>const</code></h3>
<p>Just like <code>let</code> but it&#39;s read only. Anyway you can modify a property of that const.</p>
<pre><code class="lang-js">const test = &#39;hello&#39;;
test = &#39;hi&#39;; // Uncaught TypeError: Assignment to constant variable.

// But this will work correctly
const test2 = {
    text = &#39;hello&#39;
}
test2.text = &#39;hi&#39;;
console.log(test2); // {text: &#39;hi&#39;}</code></pre>
<h3 id="replace-iifes-with-blocks">Replace IIFEs with blocks</h3>
<pre><code class="lang-js">// Instead of using IIFEs to keep variables local
(function() {
    var test = &#39;hello&#39;;
})()
console.log(test); // ReferenceError
// We can now use a block
{
    let test = &#39;hello&#39;;
}
console.log(test); // ReferenceError</code></pre>
<h2 id="string-templates">String templates</h2>
<p>Instead of use string concatenation like</p>
<pre><code class="lang-js">var a = &#39;a&#39;,
    b = &#39;b&#39;,
    c = &#39;c&#39;,
    msg = &#39;My string is &#39; + a + &#39; and &#39; + b + &#39; and &#39; + c;</code></pre>
<p>We can use templates</p>
<pre><code class="lang-js">let a = &#39;a&#39;,
    b = &#39;b&#39;,
    c = &#39;c&#39;,
    msg = `My string is ${a} and ${b} and ${c} plus javascript ops ${2+3}`</code></pre>
<h2 id="destructuring">Destructuring</h2>
<p>To extract values from objects and arrays</p>
<pre><code class="lang-js">// Instead of extract from an array
var a = [1, 2, 3],
    first = a[0],
    second = a[1],
    third = a[2];
// we can destructurate it
let b = [4, 5, 6],
    [first2, second2, third2] = b;
// and the same with objects
let c = { a: 1, b: 2, c: 3 },
    { first3, second3, third3 } = obj;
console.log(first3, third3) // returns 1, 3</code></pre>
<h3 id="spread-operator">Spread operator</h3>
<p>It gets <code>what remains</code></p>
<pre><code class="lang-js">let arr = [1, 2, 3, 4, 5]
    [head, ...tail] = arr,
    obj = { a: 6, b: 7, c: 8},
    {a, ...rest}; = obj,
    [last, ...init] = arr.reverse();
console.log(head, tail, a, rest); // 1, [2,3,4,5], 6, {b:7,c:8}
console.log(last, init); // 5, [4,3,2,1]</code></pre>
<h2 id="function-parameters">Function parameters</h2>
<p>Is a new (and needed) way to pass default params or optional ones.</p>
<pre><code class="lang-js">function sum(a = 0, b = 0) {
    return a + b;
}
console.log(sum(1)); // returns 1</code></pre>
<p>You can also use spread operator</p>
<pre><code class="lang-js">function sum (...nums) {
  return nums.reduce((sum, n) =&gt; sum + n, 0);
}
console.log(sum(1, 2, 3)); // returns 7</code></pre>
<h2 id="arrow-functions">Arrow functions</h2>
<p>Cleaner functions</p>
<pre><code class="lang-js">let incr = n =&gt; n + 1;
console.log(incr(4)); // 5</code></pre>
<p>Avoid the usage of <code>this</code>, now you can bound a function to the scope it&#39;s
defined in, and avoid using bind or <code>var that = this</code></p>
<pre><code class="lang-js">function foo(values) {
    this.values = values;
    this.incr = function() {
        this.values.map(function (n, i) {
            this.values[i] += 1;
        }.bind(this));
        return this.values;
    };
};
var op = new foo([1, 2, 3]);
op.incr(); // return [2, 3, 4]

// in ES6
function foo2(values) {
    this.values = values;
    this.incr = function() {
        this.values.map((n, i) =&gt; this.values[i] += 1);
        return this.values;
    };
}
var op2 = new foo2([1, 2, 3]);
op2.incr(); // return [2, 3, 4]</code></pre>
<h2 id="classes">Classes</h2>
<p>We&#39;ve been doing this by using other libraries, or coffeescript, but this way
makes it easier. Also, inheritance was made using .call, and now we can
<code>extend</code> our classes and call <code>super</code> to use the parent.</p>
<pre><code class="lang-js">class Animal {
  constructor(name, years) {
    this.name = name;
    this.years = years;
  }
  desc() {
    return `${this.name} is ${this.years} years old`;
  }
}

class Cat extends Animal {
  constructor (name, years) {
    super(name, years);
  }
  desc() {
    return `${super.desc()} and says Meow`;
  }
}

let cat = new Cat(&#39;Jiji&#39;, &#39;1,7&#39;);
let cat2 = new Cat(&#39;Yuki&#39;, &#39;0,5&#39;)
console.log(cat.desc()); // Jiji is 1,7 years old and says Meow
console.log(cat2.desc()); // Yuki is 0,5 years old and says Meow</code></pre>
<h2 id="getters-and-setters">Getters and setters</h2>
<p>Is a way of manipulate data when accessed and to validate data when set.</p>
<pre><code class="lang-js">class Person {
    constructor: function(name, gender) {
        this.name = name;
        this.gender = gender
    }
    get name() {
        return gender === &#39;male&#39; : `Mr. ${this.name}` : `Mrs. ${this.name}`;
    }
    set name(newName) {
        if (!newName) {
            console.log(&#39;Name can\&#39;t be empty&#39;);
        } else {
            this.name = newName;
        }
    }
}
let person = new Person(&#39;Mike&#39;, &#39;male&#39;);
console.log(person.name); // Mr. Mike
person.name = null; // Name can&#39;t be empty
person.name = &#39;Mikaela&#39;;
person.gender = &#39;female&#39;;
console.log(person.name); // Mrs. Mikaela</code></pre>
<h1 id="interesting-links">Interesting links</h1>
<ul>
<li><a href="https://leanpub.com/understandinges6/read">Understanding ECMAScript 6 book</a></li>
<li><a href="https://www.smashingmagazine.com/2015/10/es6-whats-new-next-version-javascript/">ECMAScript 6 (ES6): What’s New In The Next Version Of JavaScript</a></li>
<li><a href="https://css-tricks.com/lets-learn-es2015/">Let’s Learn ES2015</a></li>
<li><a href="http://www.2ality.com/2015/08/getting-started-es6.html">Getting started with ECMAScript 6</a></li>
<li><a href="https://es6cheatsheet.com">ES6Cheatsheet.com</a></li>
</ul>
<script src='http://localhost:35729/livereload.js'></script>

  </body>
</html>
